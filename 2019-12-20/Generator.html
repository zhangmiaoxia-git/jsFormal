<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <script>
        /*
            调用Generator函数后，该函数并不执行，返回的也不是函数的运行结果，而是一个指向内部状态的指针对象

            调用Generator函数，返回一个遍历器对象，代表Generator函数的内部指针，一开始函数是不会执行的，因为它是个状态对象


            执行Generator函数需要调用遍历器对象的next方法，返回一个有着value和done两个属性的对象

            value属性表示当前的内部状态的值，是yield或者return表达式后面的表达式的值

            done属性是一个布尔值，表示是否遍历结束，false代表没结束，true代表结束
        */    
    //    function* fn(){
    //        console.log(1);
    //        yield 'hello';
    //        console.log(2);
    //    }
    // //    console.log(fn().next());
    //    let f = fn();
    //    console.log(f.next());  //1  {value: "hello", done: false}
    //    console.log(f.next());  //2  {value: undefined, done: true}

    // function* gen(){
    //     yield 1+2;
    // }
    // console.log(gen().next().value);
    
    //Generator函数解决异步编程问题的，下面函数是一个同步编程函数，这个函数中就算有异步也算同步执行的
    // function* fn(){
    //     console.log(1);
    //     let a = yield;
    //     console.log(a);
    //     console.log(2)
    // }
    // let f = fn();
    // f.next();
    // setTimeout(()=>{
    //     f.next('异步的数据');
    // },1000);

    // function* foo(x){
    //     var y = 2 * (yield (x+1));
    //     var z = yield y;
    //     return (x+y+z);
    // }
    // var a = foo(5);
    // console.log(a.next());  //yield (x+1)的返回值{value: 6, done: false}
    // console.log(a.next(12));  //yield y的返回值{value: 24, done: false}  这次next的参数就是上次yield
    // console.log(a.next(6));  //return (x+y+z)的返回值{value: 35, done: true}


    // function* fn(){
    //     yield '1';
    //     yield '2';
    // }
    // function* ff(){
    //     yield* fn();  //'1'  '2'
    //     yield '3';
    // }
    // for(let i of ff()){
    //     console.log(i); //'1' '2'  '3'
    // }

    // let a = (function* (){
    //     yield '1'
    // })();
    // console.log(a.next().value);  //'1'

    // function* fn(g1,g2){
    //     yield* g2();  //加*可以拿到这个函数的结果
    //     yield* g1();
    // }
    // let ff = fn(function* a(){
    //     yield 1;
    // },function* b(){
    //     yield 2;
    // });
    // for(let i of ff){
    //     console.log(i);  //2  1
    // }

    // function* fn(){
    //     this.a = 11;
    // }
    // let obj = {};
    // let a = fn.call(obj);
    // a.next();
    // console.log(obj.a);  //11
    </script>
</body>
</html>